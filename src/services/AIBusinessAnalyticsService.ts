// src/services/AIBusinessAnalyticsService.ts
import axiosClient from '../api/axiosClient';
import type { 
  AnalysisType,
  AIAnalysisRequest,
  BusinessContext,
  AIAnalysisResponse,
  AnalysisHistory,
  QuickPrompt
} from '../interfaces/AIBusinessAnalyticsData';

class AIBusinessAnalyticsService {
  private baseURL = '/ai-analytics';

  async submitAnalysis(request: AIAnalysisRequest): Promise<AIAnalysisResponse> {
    try {
      const userId = this.getCurrentUserId();
      
      const payload = {
        query: request.query,
        analysisType: request.analysisType,
        language: request.language || 'en',
        userId: userId
      };

      const response = await axiosClient.post(`${this.baseURL}/analyze`, payload);
      const data = response.data;
      
      return {
        analysisId: data.analysisId,
        query: data.query,
        analysisType: data.analysisType as AnalysisType,
        status: data.status || 'processing',
        generatedAt: data.generatedAt || new Date().toISOString(),
        processingTime: data.processingTime || 0,
        confidence: data.confidence || 0,
        summary: data.summary || 'Analysis in progress...',
        detailedAnalysis: data.detailedAnalysis || 'Detailed analysis will be available once processing is complete.',
        insights: this.parseJsonField(data.insights, []),
        recommendations: this.parseJsonField(data.recommendations, []),
        dataVisualizations: this.parseJsonField(data.dataVisualizations, []),
        riskFactors: this.parseJsonField(data.riskFactors, []),
        opportunities: this.parseJsonField(data.opportunities, []),
        actionItems: this.parseJsonField(data.actionItems, []),
        relevantMetrics: this.parseJsonField(data.relevantMetrics, []),
        sources: this.parseJsonField(data.sources, []),
        disclaimer: data.disclaimer || 'This analysis is generated by AI and should be verified by human experts.',
        nextSteps: this.parseJsonField(data.nextSteps, []),
        followUpQuestions: this.parseJsonField(data.followUpQuestions, [])
      };
    } catch (error) {
      console.error('Error submitting AI analysis:', error);
      throw new Error('Failed to submit AI analysis');
    }
  }

  private parseJsonField<T>(field: any, defaultValue: T): T {
    if (!field) return defaultValue;
    if (typeof field === 'string') {
      try {
        return JSON.parse(field);
      } catch (error) {
        console.warn('Failed to parse JSON field:', error);
        return defaultValue;
      }
    }
    return field;
  }

  async getAnalysisHistory(limit: number = 50): Promise<AnalysisHistory[]> {
    try {
      const response = await axiosClient.get(`${this.baseURL}/history`, {
        params: { limit }
      });
      
      return (response.data || []).map((item: any) => ({
        analysisId: item.analysisId,
        query: item.query,
        analysisType: item.analysisType as AnalysisType,
        status: item.status,
        createdAt: item.createdAt,
        completedAt: item.completedAt,
        summary: item.summary,
        confidence: item.confidence,
        isBookmarked: item.isBookmarked || false,
        tags: item.tags ? this.parseJsonField(item.tags, []) : []
      }));
    } catch (error) {
      console.error('Error fetching analysis history:', error);
      return [];
    }
  }

  async getQuickPrompts(category?: AnalysisType): Promise<QuickPrompt[]> {
    try {
      const response = await axiosClient.get(`${this.baseURL}/prompts`, {
        params: { category }
      });
      
      return (response.data || []).map((item: any) => ({
        id: item.promptId,
        text: item.text,
        category: item.category as AnalysisType,
        icon: item.icon,
        popularity: item.popularity || 0,
        isRecommended: item.isRecommended || false
      }));
    } catch (error) {
      console.error('Error fetching quick prompts:', error);
      // Return default prompts as fallback
      return this.getDefaultQuickPrompts(category);
    }
  }

  private getDefaultQuickPrompts(category?: AnalysisType): QuickPrompt[] {
    const defaultPrompts = [
      { id: '1', text: 'Analyze my business performance', category: 'business_performance', popularity: 95, isRecommended: true },
      { id: '2', text: 'What are growth opportunities?', category: 'growth_opportunities', popularity: 88, isRecommended: true },
      { id: '3', text: 'How can I improve cash flow?', category: 'cash_flow_optimization', popularity: 82, isRecommended: true },
      { id: '4', text: 'Market expansion strategies', category: 'market_expansion', popularity: 76, isRecommended: false },
      { id: '5', text: 'Competitive analysis', category: 'competitive_analysis', popularity: 71, isRecommended: false },
      { id: '6', text: 'Risk assessment', category: 'risk_assessment', popularity: 68, isRecommended: false },
      { id: '7', text: 'Financial health check', category: 'financial_health', popularity: 85, isRecommended: true },
      { id: '8', text: 'Operational efficiency', category: 'operational_efficiency', popularity: 64, isRecommended: false },
      { id: '9', text: 'Customer insights', category: 'customer_insights', popularity: 79, isRecommended: true },
      { id: '10', text: 'Marketing strategy', category: 'marketing_strategy', popularity: 73, isRecommended: false }
    ];

    return category 
      ? defaultPrompts.filter(prompt => prompt.category === category)
      : defaultPrompts;
  }

  async getBusinessContext(): Promise<BusinessContext> {
    try {
      const response = await axiosClient.get(`${this.baseURL}/context`);
      const data = response.data;
      
      return {
        industry: data.industry || '',
        businessSize: (data.businessSize as 'startup' | 'small' | 'medium' | 'large' | 'enterprise') || 'small',
        revenueRange: data.revenueRange || '',
        employeeCount: data.employeeCount || '',
        businessModel: data.businessModel || '',
        targetMarket: data.targetMarket || '',
        geographicLocation: data.geographicLocation || '',
        yearsInOperation: data.yearsInOperation || 0,
        currentChallenges: this.parseJsonField(data.currentChallenges, []),
        businessGoals: this.parseJsonField(data.businessGoals, [])
      };
    } catch (error) {
      console.error('Error fetching business context:', error);
      return this.getDefaultBusinessContext();
    }
  }

  private getDefaultBusinessContext(): BusinessContext {
    return {
      industry: '',
      businessSize: 'small',
      revenueRange: '',
      employeeCount: '',
      businessModel: '',
      targetMarket: '',
      geographicLocation: '',
      yearsInOperation: 0,
      currentChallenges: [],
      businessGoals: []
    };
  }

  async updateBusinessContext(context: BusinessContext): Promise<BusinessContext> {
    try {
      const response = await axiosClient.put(`${this.baseURL}/context`, {
        ...context,
        currentChallenges: JSON.stringify(context.currentChallenges),
        businessGoals: JSON.stringify(context.businessGoals)
      });
      
      return response.data;
    } catch (error) {
      console.error('Error updating business context:', error);
      throw new Error('Failed to update business context');
    }
  }

  // ==================== UTILITY METHODS ====================

  private getCurrentUserId(): string {
    const userStr = localStorage.getItem('user');
    if (userStr) {
      try {
        const user = JSON.parse(userStr);
        return user.userId || user.id || '';
      } catch (e) {
        console.error('Error parsing user data:', e);
      }
    }
    throw new Error('User not authenticated');
  }

  formatProcessingTime(seconds?: number): string {
    if (!seconds) return 'N/A';
    
    if (seconds < 60) {
      return `${seconds}s`;
    } else if (seconds < 3600) {
      const minutes = Math.floor(seconds / 60);
      const remainingSeconds = seconds % 60;
      return `${minutes}m ${remainingSeconds}s`;
    } else {
      const hours = Math.floor(seconds / 3600);
      const remainingMinutes = Math.floor((seconds % 3600) / 60);
      return `${hours}h ${remainingMinutes}m`;
    }
  }

  getStatusColor(status: string): string {
    switch (status) {
      case 'processing': return 'text-blue-600';
      case 'completed': return 'text-green-600';
      case 'failed': return 'text-red-600';
      case 'cancelled': return 'text-gray-600';
      default: return 'text-gray-600';
    }
  }
}

export const aiBusinessAnalyticsService = new AIBusinessAnalyticsService();